import time
import pandas as pd
from sacrebleu.metrics import BLEU, CHRF, CHRFplusplus

# ──────────────────────────────────────────────────────────────────────────────
#  Adjust these paths as needed
INPUT_PATH   = "input_data.xlsx"
OUTPUT_PATH  = "output_data.xlsx"
REFERENCE    = "en"
KEEP_COLS    = ["es"]  # any extra metadata columns you want to keep in Detailed
MODEL_COLS   = [
    "base_madlad400_translation",
    "finetuned_madlad400_translation",
    "finetuned_helsinki_translation",
    "base_helsinki_translation",
]
METRICS      = {
    "BLEU":      BLEU(effective_order=True),
    "ChrF":      CHRF(word_order=1),
    "ChrF++":    CHRFplusplus()
}
# ──────────────────────────────────────────────────────────────────────────────

def sentence_scores(metric_obj, ref, hyp):
    """Wrap sacrebleu sentence metric call with a float return."""
    # most sacrebleu sentence metrics return a sacrebleu.Scorer object with .score
    return metric_obj.sentence_score(hyp, [ref]).score

def corpus_scores(metric_obj, refs, hyps):
    """Wrap sacrebleu corpus metric call with a float return."""
    return metric_obj.corpus_score(hyps, [refs]).score

def main():
    # 1) load your input
    df = pd.read_excel(INPUT_PATH)

    detailed_rows = []
    summary_rows  = []
    timing_rows   = []

    # 2) two runs: timing vs no‑timing
    for run_id, measure_time in [(1, True), (2, False)]:
        # per‑model response times
        model_times = { m: [] for m in MODEL_COLS }

        # --- sentence‑level / Detailed:
        for idx, row in df.iterrows():
            ref = row[REFERENCE]
            keep = { c: row[c] for c in KEEP_COLS }

            for m in MODEL_COLS:
                hyp = row[m]
                # compute each metric
                scores = {}
                for name, obj in METRICS.items():
                    if measure_time:
                        t0 = time.time()
                        sc = sentence_scores(obj, ref, hyp)
                        t1 = time.time()
                        model_times[m].append(t1 - t0)
                    else:
                        sc = sentence_scores(obj, ref, hyp)
                    scores[name] = sc

                entry = {
                    REFERENCE:    ref,
                    "model":      m,
                    "run":        run_id,
                    **keep,
                    **scores
                }
                if measure_time:
                    entry["response_time"] = model_times[m][-1]
                detailed_rows.append(entry)

        # --- corpus‑level / Summary + avg response time:
        for m in MODEL_COLS:
            refs = df[REFERENCE].tolist()
            hyps = df[m].tolist()
            corp_scores = {
                name: corpus_scores(obj, refs, hyps)
                for name, obj in METRICS.items()
            }
            avg_rt = float(pd.Series(model_times[m]).mean()) if measure_time else None

            summary_rows.append({
                "model":      m,
                "run":        run_id,
                **corp_scores,
                "avg_response_time": avg_rt
            })

        # --- store timings for the Timings sheet
        for m in MODEL_COLS:
            timing_rows.append({
                "model": m,
                "run":   run_id,
                "avg_response_time": float(pd.Series(model_times[m]).mean())
            })

    # build DataFrames
    det_df = pd.DataFrame(detailed_rows)
    sum_df = pd.DataFrame(summary_rows)
    tim_df = pd.DataFrame(timing_rows)

    # 3) pivot into the three sheets
    # 3a) Detailed: index = [REFERENCE]+KEEP_COLS, columns = (model,run), values = metrics (+response_time)
    keep = [REFERENCE] + KEEP_COLS
    values = [c for c in det_df.columns if c not in keep + ["model","run"]]
    det_pivot = det_df.pivot_table(
        index=keep,
        columns=["model","run"],
        values=values,
        aggfunc="first"
    )

    # 3b) Summary: melt then pivot so metrics×(run,model)
    long = sum_df.melt(
        id_vars=["model","run"],
        value_vars=[c for c in sum_df.columns if c not in ("model","run")],
        var_name="metric",
        value_name="score"
    )
    sum_pivot = long.pivot(
        index="metric",
        columns=["run","model"],
        values="score"
    )

    # 3c) Timings: model×run table of avg_response_time
    tim_pivot = tim_df.pivot(
        index="model",
        columns="run",
        values="avg_response_time"
    )

    # 4) write out
    with pd.ExcelWriter(OUTPUT_PATH, engine="openpyxl") as w:
        det_pivot.to_excel(w, sheet_name="Detailed")
        sum_pivot.to_excel(w, sheet_name="Summary")
        tim_pivot.to_excel(w, sheet_name="Timings")

    print(f"Wrote {OUTPUT_PATH} with sheets: Detailed, Summary, Timings")

if __name__ == "__main__":
    main()