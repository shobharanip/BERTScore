from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from pydantic import BaseModel
import evaluate
import numpy as np
import pandas as pd
import os
import tempfile
import traceback

app = FastAPI(
    title="Roberta large BERTScore API",
    description="API for calculating BERTScore between reference and candidate texts",
    version="1.0.0"
)

# Model config & load
MODEL_PATH = os.getenv("BERT", "/appdata/cortex/dev4/shared/libs/huggingface/roberta-large")
DEVICE = "cuda" if os.environ.get("CUDA_Visible_devices") else "cpu"

try:
    scorer = evaluate.load("bertscore")
    print("Metric loaded")
except Exception as e:
    print(f"Failed to load metric: {e}")
    scorer = None

class ScoreRequest(BaseModel):
    reference: list[str]
    candidate: list[str]

class ScoreResponse(BaseModel):
    precision: list[float]
    recall: list[float]
    f1: list[float]
    model_type: str = "roberta-large"
    version: str = "0.3.12"

@app.get("/")
async def health_check():
    return {
        "status": "healthy" if scorer else "failed",
        "model": "BERTScore API",
        "location": MODEL_PATH,
        "device": DEVICE
    }

@app.post("/bertscore/", response_model=ScoreResponse)
async def calculate_score(request: ScoreRequest):
    if scorer is None:
        raise HTTPException(status_code=500, detail="Metric failed to load")
    if len(request.reference) != len(request.candidate):
        raise HTTPException(status_code=400, detail="reference and candidate must have same length")
    try:
        results = scorer.compute(
            predictions=request.candidate,
            references=request.reference,
            model_type=MODEL_PATH,
            num_layers=17,
            device=DEVICE
        )
        P, R, F1 = results["precision"], results["recall"], results["f1"]
        return {
            "precision": [round(float(x), 6) for x in P],
            "recall":    [round(float(x), 6) for x in R],
            "f1":        [round(float(x), 6) for x in F1],
            "model_type":"roberta-large",
            "version":   "0.3.12"
        }
    except Exception as e:
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/batch-local/")
async def batch_local():
    if scorer is None:
        raise HTTPException(status_code=500, detail="Model failed to load")
    inp = "/appdata/cortex/dev4/shobha/input_data.xlsx"
    out = "/appdata/cortex/dev4/shobha/output_data.xlsx"

    if not os.path.exists(inp):
        raise HTTPException(status_code=404, detail=f"input not found: {inp}")

    try:
        df = pd.read_excel(inp)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Reading Excel error: {e}")

    if "reference" not in df.columns or "candidate" not in df.columns:
        raise HTTPException(status_code=400, detail="Excel must have 'reference' and 'candidate' columns")

    try:
        results = scorer.compute(
            predictions=df["candidate"].astype(str).tolist(),
            references=df["reference"].astype(str).tolist(),
            model_type=MODEL_PATH,
            num_layers=17,
            device=DEVICE
        )
        P, R, F1 = results["precision"], results["recall"], results["f1"]
        df["precision"] = [float(x) for x in P]
        df["recall"]    = [float(x) for x in R]
        df["f1"]        = [float(x) for x in F1]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Scoring error: {e}")

    try:
        df.to_excel(out, index=False)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Cannot write Excel: {e}")

    return FileResponse(
        out,
        filename=os.path.basename(out),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

@app.post("/batch-bert/")
async def batch_bert(file: UploadFile = File()):
    if scorer is None:
        raise HTTPException(status_code=500, detail="Model failed to load")
    if not file.filename.lower().endswith((".xls", ".xlsx")):
        raise HTTPException(status_code=400, detail="Upload an .xls or .xlsx file")

    try:
        df = pd.read_excel(file.file)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Cannot read Excel: {e}")

    if "reference" not in df.columns or "candidate" not in df.columns:
        raise HTTPException(status_code=400, detail="Excel must have 'reference' and 'candidate' columns")

    try:
        results = scorer.compute(
            predictions=df["candidate"].astype(str).tolist(),
            references=df["reference"].astype(str).tolist(),
            model_type=MODEL_PATH,
            num_layers=17,
            device=DEVICE
        )
        P, R, F1 = results["precision"], results["recall"], results["f1"]
        df["precision"] = [float(x) for x in P]
        df["recall"]    = [float(x) for x in R]
        df["f1"]        = [float(x) for x in F1]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Scoring error: {e}")

    tmp = tempfile.NamedTemporaryFile(suffix=".xlsx", delete=False)
    df.to_excel(tmp.name, index=False)
    tmp.close()

    return FileResponse(
        tmp.name,
        filename="bert_results.xlsx",
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)