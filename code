# batch_bertscore.py

import os
import tempfile

from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from pydantic import BaseModel

import pandas as pd
import torch
import evaluate

# ──────────────────────────────────────────────────────────────────────────────
# CONFIGURATION

# 1) Where your locally‐saved roberta-large lives
MODEL_PATH = os.getenv(
    "BERT",
    "/appdata/cortex/dev4/shared/libs/huggingface/roberta-large"
)

# 2) Evaluate expects device index: 0 for cuda:0, -1 for CPU
EVAL_DEVICE = 0 if torch.cuda.is_available() else -1

# 3) PRELOAD the BERTScore metric with both model_type & lang
#    so compute() only needs predictions + references
bertscore = evaluate.load(
    "bertscore",
    model_type = MODEL_PATH,
    lang       = "en",
    device     = EVAL_DEVICE
)

# ──────────────────────────────────────────────────────────────────────────────
# FASTAPI SETUP

app = FastAPI(
    title       = "RoBERTa‑Large BERTScore API",
    description = "Compute BERTScore with your local RoBERTa‑large checkpoint",
    version     = "1.0.0"
)

class ScoreRequest(BaseModel):
    reference: list[str]
    candidate: list[str]

class ScoreResponse(BaseModel):
    precision: list[float]
    recall:    list[float]
    f1:        list[float]
    model_type: str
    version:    str

@app.get("/")
async def health_check():
    return {
        "status": "healthy",
        "model":  f"roberta-large @ {MODEL_PATH}"
    }

@app.post("/bertscore/", response_model=ScoreResponse)
async def calculate_score(request: ScoreRequest):
    if len(request.reference) != len(request.candidate):
        raise HTTPException(
            status_code=400,
            detail="`reference` and `candidate` lists must be the same length"
        )

    try:
        results = bertscore.compute(
            predictions=request.candidate,
            references = request.reference
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"scoring error: {e}")

    return ScoreResponse(
        precision = results["precision"],
        recall    = results["recall"],
        f1        = results["f1"],
        model_type="roberta-large",
        version   ="1.0"
    )

@app.get("/batch-local/")
async def batch_local():
    inp = "/appdata/cortex/dev4/shobha/input_data.xlsx"
    if not os.path.exists(inp):
        raise HTTPException(status_code=404, detail=f"input not found: {inp}")
    return FileResponse(
        path      = inp,
        filename  = os.path.basename(inp),
        media_type= "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

@app.post("/batch-bertscore/")
async def batch_bertscore(file: UploadFile = File(...)):
    # 1) Read Excel
    try:
        df = pd.read_excel(file.file)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"cannot read Excel: {e}")

    # 2) Validate columns
    if "reference" not in df.columns or "candidate" not in df.columns:
        raise HTTPException(
            status_code=400,
            detail="Excel must have 'reference' and 'candidate' columns"
        )

    # 3) Compute BERTScore
    try:
        results = bertscore.compute(
            predictions=df["candidate"].astype(str).tolist(),
            references =df["reference"].astype(str).tolist()
        )
        df["precision"] = results["precision"]
        df["recall"]    = results["recall"]
        df["f1"]        = results["f1"]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"scoring error: {e}")

    # 4) Write out to a temp Excel
    tmp = tempfile.NamedTemporaryFile(suffix=".xlsx", delete=False)
    out = tmp.name
    tmp.close()

    try:
        df.to_excel(out, index=False)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"cannot write Excel: {e}")

    return FileResponse(
        path      = out,
        filename  = "roberta_results.xlsx",
        media_type= "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)