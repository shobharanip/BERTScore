# batch_bertscore.py

import os
import tempfile

import pandas as pd
import torch
import evaluate

from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from pydantic import BaseModel

# ──────────────────────────────────────────────────────────────────────────────
# 1) CONFIGURATION

# Point this at the folder where you unpacked roberta-large
MODEL_PATH = os.getenv(
    "BERT", 
    "/appdata/cortex/dev4/shared/libs/huggingface/roberta-large"
)

# Evaluate wants a *device index* (0 for cuda:0, -1 for CPU)
EVAL_DEVICE = 0 if torch.cuda.is_available() else -1

# 2) PRELOAD BERTScore with your local model and the English language
#    Now compute() only needs predictions + references.
bertscore = evaluate.load(
    "bertscore",
    model_type = MODEL_PATH,
    lang       = "en",
    device     = EVAL_DEVICE
)

# ──────────────────────────────────────────────────────────────────────────────
# 2) FASTAPI APP

app = FastAPI(
    title       = "RoBERTa‑Large BERTScore API",
    description = "Compute BERTScore using your local RoBERTa‑large checkpoint",
    version     = "1.0.0"
)

class ScoreRequest(BaseModel):
    reference: list[str]
    candidate: list[str]

class ScoreResponse(BaseModel):
    precision: list[float]
    recall:    list[float]
    f1:        list[float]
    model_type: str
    version:    str

@app.get("/")
async def health_check():
    return {
        "status": "healthy",
        "model":  f"roberta-large @ {MODEL_PATH}"
    }

@app.post("/bertscore/", response_model=ScoreResponse)
async def calculate_score(request: ScoreRequest):
    # ensure same length
    if len(request.reference) != len(request.candidate):
        raise HTTPException(
            status_code=400,
            detail="`reference` and `candidate` lists must have the same length"
        )
    # compute BERTScore
    try:
        results = bertsocre.compute(
            predictions=request.candidate,
            references=request.reference
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"scoring error: {e}")

    return ScoreResponse(
        precision  = results["precision"],
        recall     = results["recall"],
        f1         = results["f1"],
        model_type = "roberta-large",
        version    = "1.0"
    )

@app.get("/batch-local/")
async def batch_local():
    inp = "/appdata/cortex/dev4/shobha/input_data.xlsx"
    if not os.path.exists(inp):
        raise HTTPException(status_code=404, detail=f"file not found: {inp}")
    return FileResponse(
        path       = inp,
        filename   = os.path.basename(inp),
        media_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

@app.post("/batch-bertscore/")
async def batch_bertscore(file: UploadFile = File(...)):
    # 1) Load Excel
    try:
        df = pd.read_excel(file.file)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"cannot read Excel: {e}")

    # 2) Validate
    if "reference" not in df.columns or "candidate" not in df.columns:
        raise HTTPException(
            status_code=400,
            detail="Excel must contain 'reference' and 'candidate' columns"
        )

    # 3) Score in batch
    try:
        results = bertsocre.compute(
            predictions=df["candidate"].astype(str).tolist(),
            references=df["reference"].astype(str).tolist()
        )
        df["precision"] = results["precision"]
        df["recall"]    = results["recall"]
        df["f1"]        = results["f1"]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"scoring error: {e}")

    # 4) Write back out
    tmp = tempfile.NamedTemporaryFile(suffix=".xlsx", delete=False)
    out = tmp.name
    tmp.close()

    try:
        df.to_excel(out, index=False)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"cannot write Excel: {e}")

    return FileResponse(
        path       = out,
        filename   = "roberta_results.xlsx",
        media_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)