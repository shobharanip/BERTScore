# batch_bertscore.py

import os
import sys
import tempfile
import importlib.util

import pandas as pd
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from pydantic import BaseModel

# ──────────────────────────────────────────────────────────────────────────────
# 1) DYNAMICALLY LOAD YOUR LOCAL bertscore.py

#  the full path to your file
MODULE_PATH = "/appdata/cortex/dev4/shobha/bertscore/bertscore.py"

# tell Python “when someone does import bertscore, use this file”
spec = importlib.util.spec_from_file_location("bertscore", MODULE_PATH)
bertscore_mod = importlib.util.module_from_spec(spec)
sys.modules["bertscore"] = bertscore_mod
spec.loader.exec_module(bertscore_mod)

# now grab exactly what your file exports
from bertscore import BERTScorer, score

# ──────────────────────────────────────────────────────────────────────────────
# 2) INSTANTIATE YOUR CLASS

# point this at your local HF‐style folder if needed (or leave blank if your
# BERTScorer internally knows where to look)
MODEL_PATH = os.getenv(
    "BERT", 
    "/appdata/cortex/dev4/shared/libs/huggingface/roberta-large"
)
DEVICE = "cuda" if os.getenv("CUDA_VISIBLE_DEVICES") else "cpu"

try:
    scorer = BERTScorer(
        model_type=MODEL_PATH,
        lang="en",
        num_layers=17,   # or whatever your constructor wants
        device=DEVICE
    )
    print(f"✔️ Loaded custom BERTScorer from {MODULE_PATH}")
except Exception as e:
    print(f"❌ Failed to load custom BERTScorer: {e}")
    scorer = None

# ──────────────────────────────────────────────────────────────────────────────
# 3) FASTAPI BOILERPLATE

app = FastAPI(
    title="Custom BERTScore API",
    description="Uses your local bertsocre.py implementation",
    version="1.0.0"
)

class ScoreRequest(BaseModel):
    reference: list[str]
    candidate: list[str]

class ScoreResponse(BaseModel):
    precision: list[float]
    recall:    list[float]
    f1:        list[float]
    model_type: str
    version:    str

@app.get("/")
async def health_check():
    return {
        "status": "healthy" if scorer else "failed to load scorer",
        "model":  MODEL_PATH
    }

@app.post("/bertscore/", response_model=ScoreResponse)
async def calculate_score(request: ScoreRequest):
    if scorer is None:
        raise HTTPException(500, "Scorer not loaded")
    if len(request.reference) != len(request.candidate):
        raise HTTPException(400, "reference/candidate must be same length")
    try:
        # either call the standalone function...
        P, R, F1 = score(request.candidate, request.reference)
        # ...or if your class has a method, use:
        # P, R, F1 = scorer.score(request.candidate, request.reference)
    except Exception as e:
        raise HTTPException(500, f"scoring error: {e}")

    return ScoreResponse(
        precision  = P,
        recall     = R,
        f1         = F1,
        model_type = "custom-bertscore",
        version    = "1.0"
    )

@app.get("/batch-local/")
async def batch_local():
    inp = "/appdata/cortex/dev4/shobha/input_data.xlsx"
    if not os.path.exists(inp):
        raise HTTPException(404, f"file not found: {inp}")
    return FileResponse(inp,
                        filename=os.path.basename(inp),
                        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

@app.post("/batch-bertscore/")
async def batch_bertscore(file: UploadFile = File(...)):
    # 1) load the sheet
    try:
        df = pd.read_excel(file.file)
    except Exception as e:
        raise HTTPException(500, f"cannot read Excel: {e}")

    # 2) verify cols
    if "reference" not in df or "candidate" not in df:
        raise HTTPException(400, "Excel must have 'reference' and 'candidate' columns")

    # 3) compute
    try:
        # same choice: standalone score() or class scorer.score()
        P, R, F1 = score(df["candidate"].astype(str).tolist(),
                         df["reference"].astype(str).tolist())
        df["precision"] = P
        df["recall"]    = R
        df["f1"]        = F1
    except Exception as e:
        raise HTTPException(500, f"scoring error: {e}")

    # 4) write out
    tmp = tempfile.NamedTemporaryFile(suffix=".xlsx", delete=False)
    out = tmp.name; tmp.close()
    try:
        df.to_excel(out, index=False)
    except Exception as e:
        raise HTTPException(500, f"cannot write Excel: {e}")

    return FileResponse(out,
                        filename="results.xlsx",
                        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)