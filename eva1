%%writefile Translation_evaluator.py

import time
import pandas as pd
from sacrebleu import sentence_bleu, corpus_bleu, corpus_chrf, sentence_chrf
from typing import Union, List, Optional, Dict
import warnings
from pathlib import Path
from sacrebleu.metrics import CHRF
import os

class TranslationEvaluator:
    """
    Load data
    BLEU, chrf, Chrf++, Comet metrics
    summary
    excel genearation
    """
    def __init__(
        self,
        output_file: Union[str, Path] ="output_data.xlsx"
    ):
        os.environ["Transformers cache"] = r'C:/Users/ZKC7H0U/Documents/4. BERT score/roberta-large'
        warnings.simplefilter('ignore')

        self._data = None
        self._detailed_results = None
        self._model_metrics = None
        self._output_file = Path(output_file)

        self._chrff = CHRF(word_order=2)
        # self._timings_per_run: List[List[Dict]] = []

    def load_data(self, file_path: Union[str, Path]) -> None:
        """Load file"""
        file_path = Path(file_path)
        if file_path.suffix == '.csv':
            self._data = pd.read_csv(file_path)
        elif file_path.suffix in ('.xls', '.xlsx'):
            self._data = pd.read_excel(file_path)
        else:
            raise ValueError("unsupported file")

    def evaluate(
        self,
        prediction_cols: List[str],
        reference_col: str="en",
        metrics: List[str]=["BLEU","ChrF","ChrF++","COMET"],
        keep_cols: Optional[List[str]]=None
    ) -> None:
        import time
        """
        Run
        """
        if self._data is None:
            raise ValueError("No data loaded")

        keep_cols = keep_cols or []
        if reference_col not in keep_cols:
            keep_cols.insert(0, reference_col)

        self._validate_columns(reference_col, prediction_cols, keep_cols)
        self._compute_detailed_metrics(reference_col, prediction_cols, metrics, keep_cols)
        self._compute_model_metrics(reference_col, prediction_cols, metrics)

    def _validate_columns(
        self,
        reference_col: str,
        prediction_cols: List[str],
        keep_cols: List[str]
    ) -> None:
        """validate all columns"""
        all_columns = [reference_col] + prediction_cols + keep_cols
        missing = [col for col in all_columns if col not in self._data.columns]
        if missing:
            raise ValueError(f"columns not found in data: {missing}")

    def _compute_detailed_metrics(
        self,
        reference_col: str,
        prediction_cols: List[str],
        metrics: List[str],
        keep_cols: List[str]
    ) -> None:
        """calculate per sentence metrics"""
        cols_to_keep = keep_cols.copy()
        if reference_col not in cols_to_keep:
            cols_to_keep.insert(0, reference_col)

        self._detailed_results = self._data.copy()
        for pred_col in prediction_cols:
            if "BLEU" in metrics:
                self._detailed_results[f"{pred_col} BLEU"] = (
                    self._detailed_results
                        .apply(
                            lambda row: sentence_bleu(
                                row[pred_col], [row[reference_col]]
                            ).score,
                            axis=1
                        )
                )
            if "ChrF" in metrics:
                self._detailed_results[f"{pred_col} ChrF"] = (
                    self._detailed_results
                        .apply(
                            lambda row: sentence_chrf(
                                row[pred_col], [row[reference_col]]
                            ).score,
                            axis=1
                        )
                )
            if "ChrF++" in metrics:
                self._detailed_results[f"{pred_col} ChrF++"] = (
                    self._detailed_results
                        .apply(
                            lambda row: self._chrff.sentence_score(
                                row[pred_col], [row[reference_col]]
                            ).score,
                            axis=1
                        )
                )

        new_columns = cols_to_keep.copy()
        for pred_col in prediction_cols:
            new_columns.append(pred_col)
            if "BLEU" in metrics:
                new_columns.append(f"{pred_col} BLEU")
            if "ChrF" in metrics:
                new_columns.append(f"{pred_col} ChrF")
            if "ChrF++" in metrics:
                new_columns.append(f"{pred_col} ChrF++")

        self._detailed_results = self._detailed_results[new_columns]

    def _compute_model_metrics(
        self,
        reference_col: str,
        prediction_cols: List[str],
        metrics: List[str]
    ) -> None:
        """calculate"""
        results = []
        for pred_col in prediction_cols:
            references = self._data[reference_col].tolist()
            predictions = self._data[pred_col].tolist()
            model_results = {"Model": pred_col}
            if "BLEU" in metrics:
                model_results["BLEU"] = corpus_bleu(predictions, [references]).score
            if "ChrF" in metrics:
                model_results["ChrF"] = corpus_chrf(predictions, [references]).score
            if "ChrF++" in metrics:
                model_results["ChrF++"] = self._chrff.corpus_score(predictions, [references]).score
            results.append(model_results)

        self._model_metrics = pd.DataFrame(results)

    def _generate_report(self) -> None:
        """Generate excel report"""
        output_path = Path(self._output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with pd.ExcelWriter(output_path, engine='xlsxwriter') as writer:
            self._detailed_results.to_excel(
                writer, sheet_name="Detailed metrics", index=False
            )
            self._model_metrics.to_excel(
                writer, sheet_name="Model metrics", index=False
            )

            workbook = writer.book
            worksheet = writer.sheets["Model metrics"]
            (max_row, max_col) = self._model_metrics.shape
            column_settings = [
                {'header': col} for col in self._model_metrics.columns
            ]
            worksheet.add_table(0, 0, max_row, max_col - 1, {
                'column': column_settings,
                'style': 'Table Style Medium 9',
                'name':  'ModelMetrics'
            })
            for i, col in enumerate(self._model_metrics.columns):
                max_len = max(
                    self._model_metrics[col].astype(str).map(len).max(),
                    len(col)
                )
                worksheet.set_column(i, i, max_len + 2)

        print(f"Report saved to {output_path.resolve()}")

    def get_detailed_results(self) -> pd.DataFrame:
        """get the detailed results"""
        return self._detailed_results.copy()

    def get_model_metrics(self) -> pd.DataFrame:
        """get the model results"""
        return self._model_metrics.copy()